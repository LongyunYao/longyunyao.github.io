<!DOCTYPE html>


<html lang="en">


<head>
  <meta charset="utf-8" />
    
  <meta name="description" content="龙云尧的小角落" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
    OpenGL学习笔记（五） |  剑阁
  </title>
  <meta name="generator" content="hexo-theme-ayer">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  <link rel="stylesheet" href="/dist/main.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css">
  <link rel="stylesheet" href="/css/custom.css">
  
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
  
  

  

<link rel="alternate" href="/atom.xml" title="剑阁" type="application/atom+xml">
</head>

</html>

<body>
  <div id="app">
    
      <canvas class="fireworks"></canvas>
      <style>
        .fireworks {
          position: fixed;
          left: 0;
          top: 0;
          z-index: 99999;
          pointer-events: none;
        }
      </style>
      
      
    <main class="content on">
      <section class="outer">
  <article id="post-OpenGL学习笔记（五）" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  OpenGL学习笔记（五）
</h1>
 

    </header>
     
    <div class="article-meta">
      <a href="/2017/05/07/OpenGL学习笔记（五）/" class="article-date">
  <time datetime="2017-05-07T04:21:42.000Z" itemprop="datePublished">2017-05-07</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/C/">C++</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> Word count:</span>
            <span class="post-count">4.9k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> Reading time≈</span>
            <span class="post-count">22 min</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <p><strong>龙云尧个人博客，转载请注明出处。</strong></p>
<p>CSDN地址：<a href="http://blog.csdn.net/michael753951/article/details/71316132" target="_blank" rel="noopener">http://blog.csdn.net/michael753951/article/details/71316132</a></p>
<p>个人blog地址：<a href="http://yaoyl.cn/nehexue-xi-bi-ji-wu/" target="_blank" rel="noopener">http://yaoyl.cn/nehexue-xi-bi-ji-wu/</a></p>
<hr>
<p>这次我们将尝试Lesson6和Lesson7的内容。这个部分我们将学习怎么给一个模型进行纹理映射（其实就是贴图）。</p>
<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>这次实验因为需要使用OpenGL的glaux.h库头使用位图对构建的图形进行纹理映射。所以我们需要进一步进行环境搭建。（注：环境搭建很麻烦，因为微软的VS环境很乱）</p>
<p>如何布置这个库头可以参考<a href="http://blog.csdn.net/delphiwcdj/article/details/6326586/" target="_blank" rel="noopener">【 VS2008无法打开gl/glaux.h头文件的解决方法】</a>我使用的是方法4，测试能够正确include库头。</p>
<p>在高版本的VS中，因为VS使用的是自己重新修改过的C++，所以在进行编译的过程中，可能会出现ERROR LNK2019报错，无法解析“_sscanf,_sscanf_s”，这个时候我们可以参考<a href="http://blog.csdn.net/u010317005/article/details/51155363" target="_blank" rel="noopener">【 VS2015 无法解析的外部符号 __vsnwprintf_s】</a></p>
<p>如果我们在使用AUX_RGBImageRec定义变量的时候，系统没有报错的话，就说明我们本次基本的环境已经搭建好了。</p>
<p>另外，因为我们在实验中需要使用fopen，而微软的VS2015中会强行报错，为了避免不必要的麻烦，我们需要关掉fopen的报错。这个部分我们可以参考<a href="http://jingyan.baidu.com/article/ce436649fd61543773afd32e.html" target="_blank" rel="noopener">【百度经验：VS2013中如何解决error C4996: ‘fopen’问题】</a></p>
<h2 id="开始实现"><a href="#开始实现" class="headerlink" title="开始实现"></a>开始实现</h2><p>如果没出什么问题的话，到这里我们应该能够正常的编写这一刻的代码了。（如果还有什么报错请尝试自行解决或者戳我）。</p>
<p>本次需要在3维图像上添加纹理映射，首先需要的是读取位图像文件。读取的代码如下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">AUX_RGBImageRec *<span class="title">LoadBMP</span><span class="params">(<span class="keyword">char</span> *Filename)</span>                <span class="comment">// Loads A Bitmap Image</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE *File=<span class="literal">NULL</span>;                                    <span class="comment">// File Handle</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!Filename)                                      <span class="comment">// Make Sure A Filename Was Given</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;                                    <span class="comment">// If Not Return NULL</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    File=fopen(Filename,<span class="string">"r"</span>);                           <span class="comment">// Check To See If The File Exists</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (File)                                           <span class="comment">// Does The File Exist?</span></span><br><span class="line">    &#123;</span><br><span class="line">        fclose(File);                                   <span class="comment">// Close The Handle</span></span><br><span class="line">        <span class="keyword">return</span> auxDIBImageLoad(Filename);               <span class="comment">// Load The Bitmap And Return A Pointer</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;                                        <span class="comment">// If Load Failed Return NULL</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LoadGLTextures</span><span class="params">()</span>                                    <span class="comment">// Load Bitmaps And Convert To Textures</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Status=FALSE;                                   <span class="comment">// Status Indicator</span></span><br><span class="line"></span><br><span class="line">    AUX_RGBImageRec *TextureImage[<span class="number">1</span>];                   <span class="comment">// Create Storage Space For The Texture</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(TextureImage,<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="keyword">void</span> *)*<span class="number">1</span>);            <span class="comment">// Set The Pointer To NULL</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Load The Bitmap, Check For Errors, If Bitmap's Not Found Quit</span></span><br><span class="line">    <span class="keyword">if</span> (TextureImage[<span class="number">0</span>]=LoadBMP(<span class="string">"Data/NeHe.bmp"</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        Status=TRUE;                                    <span class="comment">// Set The Status To TRUE</span></span><br><span class="line"></span><br><span class="line">        glGenTextures(<span class="number">1</span>, &amp;texture[<span class="number">0</span>]);                  <span class="comment">// Create The Texture</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Typical Texture Generation Using Data From The Bitmap</span></span><br><span class="line">        glBindTexture(GL_TEXTURE_2D, texture[<span class="number">0</span>]);</span><br><span class="line">        glTexImage2D(GL_TEXTURE_2D, <span class="number">0</span>, <span class="number">3</span>, TextureImage[<span class="number">0</span>]-&gt;sizeX, TextureImage[<span class="number">0</span>]-&gt;sizeY, <span class="number">0</span>, GL_RGB, GL_UNSIGNED_BYTE, TextureImage[<span class="number">0</span>]-&gt;data);</span><br><span class="line">        glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR);</span><br><span class="line">        glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (TextureImage[<span class="number">0</span>])                                    <span class="comment">// If Texture Exists</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (TextureImage[<span class="number">0</span>]-&gt;data)                          <span class="comment">// If Texture Image Exists</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">free</span>(TextureImage[<span class="number">0</span>]-&gt;data);                    <span class="comment">// Free The Texture Image Memory</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">free</span>(TextureImage[<span class="number">0</span>]);                              <span class="comment">// Free The Image Structure</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Status;                                      <span class="comment">// Return The Status</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一个函数LoadBMP不需要解释，主要功能就是探寻目的位置中是否存在该图像文件。如果存在就调用auxDIBImageLoad将位图加载成渲染文件返回出来。</p>
<p>第二个函数LoadGLTextures要稍微注意一下，在本次实验中是很重要的一个功能函数。</p>
<p>函数中定义了一个LoadGLTextures数组用来存放位图的句柄，这里因为我们只读取了一张位图，所以只开了一个大小的数组。</p>
<p>接着调用LoadBMP将位图转换成为纹理渲染文件存进TextureImage， glGenTextures(1, &amp;texture[0]) 告诉OpenGL我们想生成一个纹理名字，glBindTexture将纹理名字 texture[0] 绑定到纹理目标上。</p>
<p>然后我们调用glTexImage2D进行纹理的创建。然后使用glTexParameteri对图像进行放大和缩小的滤波器进行设置。</p>
<p>最后再纹理穿件完成之后，我们需要释放掉纹理渲染数组中的内容。</p>
<p>整个纹理渲染工作到这里也就结束了。我们对InitGL稍作修改，使用LoadGLTextures检验位图是否存在，然后调用glEnable启用映射</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">InitGL</span><span class="params">(GLvoid)</span>        <span class="comment">// 此处开始对OpenGL进行所有设置</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (!LoadGLTextures())       <span class="comment">// 调用纹理载入子例程</span></span><br><span class="line"> &#123;</span><br><span class="line">  <span class="keyword">return</span> FALSE;       <span class="comment">// 如果未能载入，返回FALSE</span></span><br><span class="line"> &#125;</span><br><span class="line"> glEnable(GL_TEXTURE_2D);      <span class="comment">// 启用纹理映射</span></span><br><span class="line"> glShadeModel(GL_SMOOTH);      <span class="comment">// 启用阴影平滑</span></span><br><span class="line"> glClearColor(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.5f</span>);     <span class="comment">// 黑色背景</span></span><br><span class="line"> glClearDepth(<span class="number">1.0f</span>);       <span class="comment">// 设置深度缓存</span></span><br><span class="line"> glEnable(GL_DEPTH_TEST);      <span class="comment">// 启用深度测试</span></span><br><span class="line"> glDepthFunc(GL_LEQUAL);       <span class="comment">// 所作深度测试的类型</span></span><br><span class="line"> glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST);   <span class="comment">// 真正精细的透视修正</span></span><br><span class="line"> <span class="keyword">return</span> TRUE;        <span class="comment">// 初始化 OK</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后我们按照惯例，修改DrawGLScene方法，需要注意的是，在将纹理贴上模型的时候，需要调用glTexCoord2f方法，第一个参数是X坐标，0.0是纹理的左侧，0.5是纹理的中点，1.0是纹理的右侧。第二个参数是Y坐标，0.0是纹理的底部，0.5是纹理的中点，1.0是纹理的顶部。将4个点全部绑定在张芳行上面之后，便能够正常的显示了。需要注意的是，在glTexCoord2f方法中，参考系是以图像的右下角作为原点，左边为X轴正方向，上方为Y轴正方向（和绘图中的直角坐标系的设定相似）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">int DrawGLScene(GLvoid)                                 // Here&apos;s Where We Do All The Drawing</span><br><span class="line">&#123;</span><br><span class="line">    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); // Clear The Screen And The Depth Buffer</span><br><span class="line">    glLoadIdentity();                                   // Reset The View</span><br><span class="line">    glTranslatef(0.0f,0.0f,-5.0f);</span><br><span class="line"></span><br><span class="line">    glRotatef(xrot,1.0f,0.0f,0.0f);</span><br><span class="line">    glRotatef(yrot,0.0f,1.0f,0.0f);</span><br><span class="line">    glRotatef(zrot,0.0f,0.0f,1.0f);</span><br><span class="line"></span><br><span class="line">    glBindTexture(GL_TEXTURE_2D, texture[0]);</span><br><span class="line"></span><br><span class="line">    glBegin(GL_QUADS);</span><br><span class="line">        // Front Face</span><br><span class="line">        glTexCoord2f(0.0f, 0.0f); glVertex3f(-1.0f, -1.0f,  1.0f);</span><br><span class="line">        glTexCoord2f(1.0f, 0.0f); glVertex3f( 1.0f, -1.0f,  1.0f);</span><br><span class="line">        glTexCoord2f(1.0f, 1.0f); glVertex3f( 1.0f,  1.0f,  1.0f);</span><br><span class="line">        glTexCoord2f(0.0f, 1.0f); glVertex3f(-1.0f,  1.0f,  1.0f);</span><br><span class="line">        // Back Face</span><br><span class="line">        glTexCoord2f(1.0f, 0.0f); glVertex3f(-1.0f, -1.0f, -1.0f);</span><br><span class="line">        glTexCoord2f(1.0f, 1.0f); glVertex3f(-1.0f,  1.0f, -1.0f);</span><br><span class="line">        glTexCoord2f(0.0f, 1.0f); glVertex3f( 1.0f,  1.0f, -1.0f);</span><br><span class="line">        glTexCoord2f(0.0f, 0.0f); glVertex3f( 1.0f, -1.0f, -1.0f);</span><br><span class="line">        // Top Face</span><br><span class="line">        glTexCoord2f(0.0f, 1.0f); glVertex3f(-1.0f,  1.0f, -1.0f);</span><br><span class="line">        glTexCoord2f(0.0f, 0.0f); glVertex3f(-1.0f,  1.0f,  1.0f);</span><br><span class="line">        glTexCoord2f(1.0f, 0.0f); glVertex3f( 1.0f,  1.0f,  1.0f);</span><br><span class="line">        glTexCoord2f(1.0f, 1.0f); glVertex3f( 1.0f,  1.0f, -1.0f);</span><br><span class="line">        // Bottom Face</span><br><span class="line">        glTexCoord2f(1.0f, 1.0f); glVertex3f(-1.0f, -1.0f, -1.0f);</span><br><span class="line">        glTexCoord2f(0.0f, 1.0f); glVertex3f( 1.0f, -1.0f, -1.0f);</span><br><span class="line">        glTexCoord2f(0.0f, 0.0f); glVertex3f( 1.0f, -1.0f,  1.0f);</span><br><span class="line">        glTexCoord2f(1.0f, 0.0f); glVertex3f(-1.0f, -1.0f,  1.0f);</span><br><span class="line">        // Right face</span><br><span class="line">        glTexCoord2f(1.0f, 0.0f); glVertex3f( 1.0f, -1.0f, -1.0f);</span><br><span class="line">        glTexCoord2f(1.0f, 1.0f); glVertex3f( 1.0f,  1.0f, -1.0f);</span><br><span class="line">        glTexCoord2f(0.0f, 1.0f); glVertex3f( 1.0f,  1.0f,  1.0f);</span><br><span class="line">        glTexCoord2f(0.0f, 0.0f); glVertex3f( 1.0f, -1.0f,  1.0f);</span><br><span class="line">        // Left Face</span><br><span class="line">        glTexCoord2f(0.0f, 0.0f); glVertex3f(-1.0f, -1.0f, -1.0f);</span><br><span class="line">        glTexCoord2f(1.0f, 0.0f); glVertex3f(-1.0f, -1.0f,  1.0f);</span><br><span class="line">        glTexCoord2f(1.0f, 1.0f); glVertex3f(-1.0f,  1.0f,  1.0f);</span><br><span class="line">        glTexCoord2f(0.0f, 1.0f); glVertex3f(-1.0f,  1.0f, -1.0f);</span><br><span class="line">    glEnd();</span><br><span class="line"></span><br><span class="line">    xrot+=0.3f;</span><br><span class="line">    yrot+=0.2f;</span><br><span class="line">    zrot+=0.4f;</span><br><span class="line">    return TRUE;                                        // Keep Going</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法中，在begin之前，我们先预先定义好图像的旋转方式（不一定非要放在begin之前）。</p>
<p>接着调用glBindTexture进行绑定。我们就能够开始进行纹理渲染的绑定操作了。</p>
<p>操作中我们在每次定义点的同时，将纹理的四个角也固定在对应的点上，便能够完成绑定工作。</p>
<p>注意，用原引博客的话说，<strong>当您想改变纹理时，应该绑定新的纹理。有一点值得指出的是，您不能在 glBegin() 和 glEnd() 之间绑定纹理，必须在 glBegin() 之前或 glEnd() 之后绑定。</strong></p>
<p>到这一步，这一课内容也就结束了。</p>
<p><img src="http://img.blog.csdn.net/20170516074420532?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTWljaGFlbDc1Mzk1MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="section5.1"></p>
<h2 id="课程7的实现"><a href="#课程7的实现" class="headerlink" title="课程7的实现"></a>课程7的实现</h2><p>我们接下来尝试课程7的内容。</p>
<p>课程7将带领我们建立一个光照系统，我们也将在这个课程中尝试添加按键控制。通过这个课程，我们会对OpenGL中的光照系统的实现、控制以及如何实现按键控制有一个入门的了解。本次实验基于课程6的内容进行进一步扩展。</p>
<p>实验中，因为我们需要首先添加一些群居变量用来对按键状态进行识别，同时也还要添加一些全局变量用来记录图像的旋转角度。</p>
<p>因此我们在全局变量中添加如下变量。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">GLfloat xrot;               <span class="comment">// X 旋转角度</span></span><br><span class="line">GLfloat yrot;               <span class="comment">// Y 旋转角度</span></span><br><span class="line">GLfloat xspeed;             <span class="comment">// X 旋转速度</span></span><br><span class="line">GLfloat yspeed;             <span class="comment">// Y 旋转速度</span></span><br><span class="line">GLfloat z=<span class="number">-5.0f</span>;            <span class="comment">// Depth Into The Screen</span></span><br><span class="line"></span><br><span class="line">GLfloat LightAmbient[]=     &#123; <span class="number">0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.5f</span>, <span class="number">1.0f</span> &#125;;</span><br><span class="line">GLfloat LightDiffuse[]=     &#123; <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span> &#125;;</span><br><span class="line">GLfloat LightPosition[]=    &#123; <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">2.0f</span>, <span class="number">1.0f</span> &#125;;</span><br><span class="line"></span><br><span class="line">GLuint  filter;             <span class="comment">// 滤波器类型</span></span><br><span class="line">GLuint  texture[<span class="number">3</span>];         <span class="comment">// 3中纹理文件指针</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，中间3行数组分别表示环境光变量数组，漫射光变量数组，以及光源位置数组。</p>
<p>其中，我们需要了解一下环境光和漫射光的意义是什么。<strong>环境光来自于四面八方。所有场景中的对象都处于环境光的照射中；漫射光由特定的光源产生，并在您的场景中的对象表面上产生反射。处于漫射光直接照射下的任何对象表面都变得很亮，而几乎未被照射到的区域就显得要暗一些。</strong></p>
<p>LightAmbient和LightDiffuse创建光源的过程和颜色的创建完全一致。前三个参数分别是RGB三色分量，最后一个是alpha通道参数。</p>
<p>而LightPosition中，前三个参数表示光源的XYZ左坐标，最后一个参数将告诉OpenGL这里指定的坐标就是光源的位置。</p>
<p>然后我们在上一次实验的基础上稍稍稍修改LoadGLTextures函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LoadGLTextures</span><span class="params">()</span>                                    <span class="comment">// Load Bitmaps And Convert To Textures</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Status=FALSE;                                   <span class="comment">// Status Indicator</span></span><br><span class="line"></span><br><span class="line">    AUX_RGBImageRec *TextureImage[<span class="number">1</span>];                   <span class="comment">// Create Storage Space For The Texture</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(TextureImage,<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="keyword">void</span> *)*<span class="number">1</span>);            <span class="comment">// Set The Pointer To NULL</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Load The Bitmap, Check For Errors, If Bitmap's Not Found Quit</span></span><br><span class="line">    <span class="keyword">if</span> (TextureImage[<span class="number">0</span>]=LoadBMP(<span class="string">"Data/Crate.bmp"</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        Status=TRUE;                                    <span class="comment">// Set The Status To TRUE</span></span><br><span class="line"></span><br><span class="line">        glGenTextures(<span class="number">3</span>, &amp;texture[<span class="number">0</span>]);                  <span class="comment">// Create Three Textures</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create Nearest Filtered Texture</span></span><br><span class="line">        glBindTexture(GL_TEXTURE_2D, texture[<span class="number">0</span>]);</span><br><span class="line">        glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_NEAREST);</span><br><span class="line">        glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_NEAREST);</span><br><span class="line">        glTexImage2D(GL_TEXTURE_2D, <span class="number">0</span>, <span class="number">3</span>, TextureImage[<span class="number">0</span>]-&gt;sizeX, TextureImage[<span class="number">0</span>]-&gt;sizeY, <span class="number">0</span>, GL_RGB, GL_UNSIGNED_BYTE, TextureImage[<span class="number">0</span>]-&gt;data);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create Linear Filtered Texture</span></span><br><span class="line">        glBindTexture(GL_TEXTURE_2D, texture[<span class="number">1</span>]);</span><br><span class="line">        glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);</span><br><span class="line">        glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR);</span><br><span class="line">        glTexImage2D(GL_TEXTURE_2D, <span class="number">0</span>, <span class="number">3</span>, TextureImage[<span class="number">0</span>]-&gt;sizeX, TextureImage[<span class="number">0</span>]-&gt;sizeY, <span class="number">0</span>, GL_RGB, GL_UNSIGNED_BYTE, TextureImage[<span class="number">0</span>]-&gt;data);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create MipMapped Texture</span></span><br><span class="line">        glBindTexture(GL_TEXTURE_2D, texture[<span class="number">2</span>]);</span><br><span class="line">        glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);</span><br><span class="line">        glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR_MIPMAP_NEAREST);</span><br><span class="line">        </span><br><span class="line">        gluBuild2DMipmaps(GL_TEXTURE_2D, <span class="number">3</span>, TextureImage[<span class="number">0</span>]-&gt;sizeX, TextureImage[<span class="number">0</span>]-&gt;sizeY, GL_RGB, GL_UNSIGNED_BYTE, TextureImage[<span class="number">0</span>]-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (TextureImage[<span class="number">0</span>])                                <span class="comment">// If Texture Exists</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (TextureImage[<span class="number">0</span>]-&gt;data)                      <span class="comment">// If Texture Image Exists</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">free</span>(TextureImage[<span class="number">0</span>]-&gt;data);                <span class="comment">// Free The Texture Image Memory</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">free</span>(TextureImage[<span class="number">0</span>]);                          <span class="comment">// Free The Image Structure</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Status;                                      <span class="comment">// Return The Status</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在读过上一次的代码之后，我们可以很容易的知道这段代码就是将Data/Crate.bmp这张位图转换成纹理并且存放在texture数组中，并且3次渲染的画面都一致（基于这一点，其实我们也可以自己实现不同的3张图片做出3种不同的，不同的是3章图像的glTexParameteri进行滤波的方式并不相同，第一张渲染使用最邻近过滤（GL_NEAREST），第二张使用线性滤波（GL_LINEAR），第三张使用选择最邻近的mip层，使用线性过滤（GL_LINEAR_MIPMAP_NEAREST）。然后就可以在立方体上渲染出不同的团了）。其他的部分改变不大。</p>
<p>上面对纹理映射的滤波器的选择可以参考<a href="https://my.oschina.net/sweetdark/blog/177812" target="_blank" rel="noopener">【OpenGL超级宝典笔记——纹理映射Mipmap】</a>这篇博客，在上面有很详细的解释和说明。</p>
<p>然后在滤波器设置结束之后，最后一行还添加了一个gluBuild2DMipmaps方法，这个在上面的【OpenGL超级宝典笔记——纹理映射Mipmap】中也有提到，是一个能够将任意图像正常缩放到适当大小的方法函数，这样就不用我们费心进行图像的预处理工作了。</p>
<p>好了，到这里LoadGLTextures就设置完毕了。</p>
<p>接着就到InitGL函数了，我们在第六课中已经设置了GLEnable以及glHint进行纹理绑定工作了。我们需要在后面添加新的方法，用来实现光源的初始化。具体参考代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">InitGL</span><span class="params">(GLvoid)</span>                                      <span class="comment">// All Setup For OpenGL Goes Here</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!LoadGLTextures())                              <span class="comment">// Jump To Texture Loading Routine</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;                                   <span class="comment">// If Texture Didn't Load Return FALSE</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    glEnable(GL_TEXTURE_2D);                            <span class="comment">// Enable Texture Mapping</span></span><br><span class="line">    glShadeModel(GL_SMOOTH);                            <span class="comment">// Enable Smooth Shading</span></span><br><span class="line">    glClearColor(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.5f</span>);               <span class="comment">// Black Background</span></span><br><span class="line">    glClearDepth(<span class="number">1.0f</span>);                                 <span class="comment">// Depth Buffer Setup</span></span><br><span class="line">    glEnable(GL_DEPTH_TEST);                            <span class="comment">// Enables Depth Testing</span></span><br><span class="line">    glDepthFunc(GL_LEQUAL);                             <span class="comment">// The Type Of Depth Testing To Do</span></span><br><span class="line">    glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST);  <span class="comment">// Really Nice Perspective Calculations</span></span><br><span class="line"></span><br><span class="line">    glLightfv(GL_LIGHT1, GL_AMBIENT, LightAmbient);     <span class="comment">// Setup The Ambient Light</span></span><br><span class="line">    glLightfv(GL_LIGHT1, GL_DIFFUSE, LightDiffuse);     <span class="comment">// Setup The Diffuse Light</span></span><br><span class="line">    glLightfv(GL_LIGHT1, GL_POSITION,LightPosition);    <span class="comment">// Position The Light</span></span><br><span class="line">    glEnable(GL_LIGHT1);                                <span class="comment">// Enable Light One</span></span><br><span class="line">    <span class="keyword">return</span> TRUE;                                        <span class="comment">// Initialization Went OK</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新增了一个1号光源GL_LIGHT1。在对GL_LIGHT新增的3个glLightfv方法中，第一个表示设置环境光（Ambient Light），传入我们已经定义好的全局变量LightAmbient；第二个是漫射光（Diffuse Light），传入我们已经定义好的全局变量LightDiffuse；第三个是光源位置，传入我们定义好的LightPosition。最后使用glEnable启用光源。</p>
<p>到这里点光源的初始化操作就结束了。和设置渲染一样，我们接着要在DrawGLScene中添加光源的某些设置，</p>
<p>在OpenGL中，法线是指经过面(多边形）上的一点且垂直于这个面(多边形)的直线。使用光源的时候必须指定一条法线。法线告诉OpenGL这个多边形的朝向，并指明多边形的正面和背面。如果没有指定法线，什么怪事情都可能发生：不该照亮的面被照亮了，多边形的背面也被照亮….。对了，法线应该指向多边形的外侧。</p>
<p>所以我们在DrawGLScene中绘制图像的时候，也要同时设置法线。一般来说在绘制一个平面之前，我们就要预先定义好这个平面的法线。参考代码如下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DrawGLScene</span><span class="params">(GLvoid)</span>                                 <span class="comment">// Here's Where We Do All The Drawing</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); <span class="comment">// Clear The Screen And The Depth Buffer</span></span><br><span class="line">    glLoadIdentity();                                   <span class="comment">// Reset The View</span></span><br><span class="line">    glTranslatef(<span class="number">0.0f</span>,<span class="number">0.0f</span>,z);</span><br><span class="line"></span><br><span class="line">    glRotatef(xrot,<span class="number">1.0f</span>,<span class="number">0.0f</span>,<span class="number">0.0f</span>);</span><br><span class="line">    glRotatef(yrot,<span class="number">0.0f</span>,<span class="number">1.0f</span>,<span class="number">0.0f</span>);</span><br><span class="line"></span><br><span class="line">    glBindTexture(GL_TEXTURE_2D, texture[filter]);</span><br><span class="line"></span><br><span class="line">    glBegin(GL_QUADS);</span><br><span class="line">        <span class="comment">// Front Face</span></span><br><span class="line">        glNormal3f( <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line">        glTexCoord2f(<span class="number">0.0f</span>, <span class="number">0.0f</span>); glVertex3f(<span class="number">-1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>);</span><br><span class="line">        glTexCoord2f(<span class="number">1.0f</span>, <span class="number">0.0f</span>); glVertex3f( <span class="number">1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>);</span><br><span class="line">        glTexCoord2f(<span class="number">1.0f</span>, <span class="number">1.0f</span>); glVertex3f( <span class="number">1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>);</span><br><span class="line">        glTexCoord2f(<span class="number">0.0f</span>, <span class="number">1.0f</span>); glVertex3f(<span class="number">-1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>);</span><br><span class="line">        <span class="comment">// Back Face</span></span><br><span class="line">        glNormal3f( <span class="number">0.0f</span>, <span class="number">0.0f</span>,<span class="number">-1.0f</span>);</span><br><span class="line">        glTexCoord2f(<span class="number">1.0f</span>, <span class="number">0.0f</span>); glVertex3f(<span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>);</span><br><span class="line">        glTexCoord2f(<span class="number">1.0f</span>, <span class="number">1.0f</span>); glVertex3f(<span class="number">-1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>);</span><br><span class="line">        glTexCoord2f(<span class="number">0.0f</span>, <span class="number">1.0f</span>); glVertex3f( <span class="number">1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>);</span><br><span class="line">        glTexCoord2f(<span class="number">0.0f</span>, <span class="number">0.0f</span>); glVertex3f( <span class="number">1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>);</span><br><span class="line">        <span class="comment">// Top Face</span></span><br><span class="line">        glNormal3f( <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line">        glTexCoord2f(<span class="number">0.0f</span>, <span class="number">1.0f</span>); glVertex3f(<span class="number">-1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>);</span><br><span class="line">        glTexCoord2f(<span class="number">0.0f</span>, <span class="number">0.0f</span>); glVertex3f(<span class="number">-1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>);</span><br><span class="line">        glTexCoord2f(<span class="number">1.0f</span>, <span class="number">0.0f</span>); glVertex3f( <span class="number">1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>);</span><br><span class="line">        glTexCoord2f(<span class="number">1.0f</span>, <span class="number">1.0f</span>); glVertex3f( <span class="number">1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>);</span><br><span class="line">        <span class="comment">// Bottom Face</span></span><br><span class="line">        glNormal3f( <span class="number">0.0f</span>,<span class="number">-1.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line">        glTexCoord2f(<span class="number">1.0f</span>, <span class="number">1.0f</span>); glVertex3f(<span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>);</span><br><span class="line">        glTexCoord2f(<span class="number">0.0f</span>, <span class="number">1.0f</span>); glVertex3f( <span class="number">1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>);</span><br><span class="line">        glTexCoord2f(<span class="number">0.0f</span>, <span class="number">0.0f</span>); glVertex3f( <span class="number">1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>);</span><br><span class="line">        glTexCoord2f(<span class="number">1.0f</span>, <span class="number">0.0f</span>); glVertex3f(<span class="number">-1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>);</span><br><span class="line">        <span class="comment">// Right face</span></span><br><span class="line">        glNormal3f( <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line">        glTexCoord2f(<span class="number">1.0f</span>, <span class="number">0.0f</span>); glVertex3f( <span class="number">1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>);</span><br><span class="line">        glTexCoord2f(<span class="number">1.0f</span>, <span class="number">1.0f</span>); glVertex3f( <span class="number">1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>);</span><br><span class="line">        glTexCoord2f(<span class="number">0.0f</span>, <span class="number">1.0f</span>); glVertex3f( <span class="number">1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>);</span><br><span class="line">        glTexCoord2f(<span class="number">0.0f</span>, <span class="number">0.0f</span>); glVertex3f( <span class="number">1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>);</span><br><span class="line">        <span class="comment">// Left Face</span></span><br><span class="line">        glNormal3f(<span class="number">-1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line">        glTexCoord2f(<span class="number">0.0f</span>, <span class="number">0.0f</span>); glVertex3f(<span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>);</span><br><span class="line">        glTexCoord2f(<span class="number">1.0f</span>, <span class="number">0.0f</span>); glVertex3f(<span class="number">-1.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>);</span><br><span class="line">        glTexCoord2f(<span class="number">1.0f</span>, <span class="number">1.0f</span>); glVertex3f(<span class="number">-1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>);</span><br><span class="line">        glTexCoord2f(<span class="number">0.0f</span>, <span class="number">1.0f</span>); glVertex3f(<span class="number">-1.0f</span>,  <span class="number">1.0f</span>, <span class="number">-1.0f</span>);</span><br><span class="line">    glEnd();</span><br><span class="line"></span><br><span class="line">    xrot+=xspeed;</span><br><span class="line">    yrot+=yspeed;</span><br><span class="line">    <span class="keyword">return</span> TRUE;                                        <span class="comment">// Keep Going</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每新定义一个平面，我们都需要调用glNormal3f定义好一个法向量。法向量的3个参数分别表示其在X轴，Y轴，Z轴上的分量的长度。法向量的值是由面上的点计算出来的。</p>
<p>到这一步，我们编译运行以后就已经能够看到在点光源下的一个木箱子的图案，接下来我们将为其添加键盘控制功能。这部分在WinMain内。</p>
<p>我们在课程1上已经知道，nehe教程中，按键的反馈是在WinMain的一个while循环中，不断检测事件，然后对不同事件进行相应的反馈。里面已经添加了F1进行全屏控制的时间控制，我们要做的就是模仿F1的工作机制，添加其他按键的反馈。</p>
<p>在以前的while循环中，按键的触发设置代码如下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(!done)                                    <span class="comment">// Loop That Runs While done=FALSE</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (PeekMessage(&amp;msg,<span class="literal">NULL</span>,<span class="number">0</span>,<span class="number">0</span>,PM_REMOVE))   <span class="comment">// Is There A Message Waiting?</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (msg.message==WM_QUIT)               <span class="comment">// Have We Received A Quit Message?</span></span><br><span class="line">        &#123;</span><br><span class="line">            done=TRUE;                          <span class="comment">// If So done=TRUE</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>                                    <span class="comment">// If Not, Deal With Window Messages</span></span><br><span class="line">        &#123;</span><br><span class="line">            TranslateMessage(&amp;msg);             <span class="comment">// Translate The Message</span></span><br><span class="line">            DispatchMessage(&amp;msg);              <span class="comment">// Dispatch The Message</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>                                        <span class="comment">// If There Are No Messages</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Draw The Scene.  Watch For ESC Key And Quit Messages From DrawGLScene()</span></span><br><span class="line">        <span class="keyword">if</span> ((active &amp;&amp; !DrawGLScene()) || keys[VK_ESCAPE])  <span class="comment">// Active?  Was There A Quit Received?</span></span><br><span class="line">        &#123;</span><br><span class="line">            done=TRUE;                          <span class="comment">// ESC or DrawGLScene Signalled A Quit</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>                                    <span class="comment">// Not Time To Quit, Update Screen</span></span><br><span class="line">        &#123;</span><br><span class="line">            SwapBuffers(hDC);                   <span class="comment">// Swap Buffers (Double Buffering)</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (keys[VK_F1])                        <span class="comment">// Is F1 Being Pressed?</span></span><br><span class="line">        &#123;</span><br><span class="line">            keys[VK_F1]=FALSE;                  <span class="comment">// If So Make Key FALSE</span></span><br><span class="line">            KillGLWindow();                     <span class="comment">// Kill Our Current Window</span></span><br><span class="line">            fullscreen=!fullscreen;             <span class="comment">// Toggle Fullscreen / Windowed Mode</span></span><br><span class="line">            <span class="comment">// Recreate Our OpenGL Window</span></span><br><span class="line">            <span class="keyword">if</span> (!CreateGLWindow(<span class="string">"NeHe's Texture Mapping Tutorial"</span>,<span class="number">640</span>,<span class="number">480</span>,<span class="number">16</span>,fullscreen))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;                       <span class="comment">// Quit If Window Was Not Created</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在确认ESC按键未被按下之前，OpenGL将会不停的绘制图片。在这个窗口刷新工作结束以后，我们开始了F1的按键判断。由此，我们可以在这个基础上，进一步扩展了。扩展的代码如下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!done)                                   <span class="comment">// Loop That Runs While done=FALSE</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (PeekMessage(&amp;msg, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>, PM_REMOVE))   <span class="comment">// Is There A Message Waiting?</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (msg.message == WM_QUIT)             <span class="comment">// Have We Received A Quit Message?</span></span><br><span class="line">            &#123;</span><br><span class="line">                done = TRUE;                            <span class="comment">// If So done=TRUE</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>                                    <span class="comment">// If Not, Deal With Window Messages</span></span><br><span class="line">            &#123;</span><br><span class="line">                TranslateMessage(&amp;msg);             <span class="comment">// Translate The Message</span></span><br><span class="line">                DispatchMessage(&amp;msg);              <span class="comment">// Dispatch The Message</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>                                        <span class="comment">// If There Are No Messages</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Draw The Scene.  Watch For ESC Key And Quit Messages From DrawGLScene()</span></span><br><span class="line">            <span class="keyword">if</span> ((active &amp;&amp; !DrawGLScene()) || keys[VK_ESCAPE])  <span class="comment">// Active?  Was There A Quit Received?</span></span><br><span class="line">            &#123;</span><br><span class="line">                done = TRUE;                            <span class="comment">// ESC or DrawGLScene Signalled A Quit</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>                                    <span class="comment">// Not Time To Quit, Update Screen</span></span><br><span class="line">            &#123;</span><br><span class="line">                SwapBuffers(hDC);                   <span class="comment">// Swap Buffers (Double Buffering)</span></span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (keys[<span class="string">'L'</span>] &amp;&amp; !lp)</span><br><span class="line">            &#123;</span><br><span class="line">                lp = TRUE;</span><br><span class="line">                light = !light;</span><br><span class="line">                <span class="keyword">if</span> (!light)</span><br><span class="line">                &#123;</span><br><span class="line">                    glDisable(GL_LIGHTING);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    glEnable(GL_LIGHTING);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!keys[<span class="string">'L'</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                lp = FALSE;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (keys[<span class="string">'F'</span>] &amp;&amp; !fp)</span><br><span class="line">            &#123;</span><br><span class="line">                fp = TRUE;</span><br><span class="line">                filter += <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (filter&gt;<span class="number">2</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    filter = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!keys[<span class="string">'F'</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                fp = FALSE;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (keys[VK_PRIOR])</span><br><span class="line">            &#123;</span><br><span class="line">                z -= <span class="number">0.02f</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (keys[VK_NEXT])</span><br><span class="line">            &#123;</span><br><span class="line">                z += <span class="number">0.02f</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (keys[VK_UP])</span><br><span class="line">            &#123;</span><br><span class="line">                xspeed -= <span class="number">0.01f</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (keys[VK_DOWN])</span><br><span class="line">            &#123;</span><br><span class="line">                xspeed += <span class="number">0.01f</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (keys[VK_RIGHT])</span><br><span class="line">            &#123;</span><br><span class="line">                yspeed += <span class="number">0.01f</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (keys[VK_LEFT])</span><br><span class="line">            &#123;</span><br><span class="line">                yspeed -= <span class="number">0.01f</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (keys[VK_F1])                        <span class="comment">// Is F1 Being Pressed?</span></span><br><span class="line">            &#123;</span><br><span class="line">                keys[VK_F1] = FALSE;                    <span class="comment">// If So Make Key FALSE</span></span><br><span class="line">                KillGLWindow();                     <span class="comment">// Kill Our Current Window</span></span><br><span class="line">                fullscreen = !fullscreen;               <span class="comment">// Toggle Fullscreen / Windowed Mode</span></span><br><span class="line">                                                        <span class="comment">// Recreate Our OpenGL Window</span></span><br><span class="line">                <span class="keyword">if</span> (!CreateGLWindow(<span class="string">"NeHe's Textures, Lighting &amp; Keyboard Tutorial"</span>, <span class="number">640</span>, <span class="number">480</span>, <span class="number">16</span>, fullscreen))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;                       <span class="comment">// Quit If Window Was Not Created</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>如果按下L建，就对光源GL_LIGHTING进行改变（我们在初始化InitGL的时候，就曾经调用过glEnable，不知道你是否还有印象）。其他部分都不难，这里就不一一解释了。</p>
<p>另外需要说明的是，因为在NEHE教程的前文中，按键反馈是在刷新屏幕<code>if ((active &amp;&amp; !DrawGLScene()) || keys[VK_ESCAPE])</code>这个判断结束之后才进行的按键反馈，而在其之后的代码中，却又将ESC之外的按键触发部分放进了判断条件之内。我这里模仿的是作者以前的按键触发设置，所以代码和作者lesson7的代码稍有不同。不过最终效果其实一致——只不过我的会在按下ESC之后延迟一帧才推出，而作者按下ESC立刻退出，因为刷新频率很快，所以其实想过一只。</p>
<p>最后，实验正确运行的话，你应该能够在窗口中正常的运行你的第一个有按键反馈的窗口游戏了。L打开灯光，F设置不同的滤波器，上下左右方向键分别设置不同的旋转方向，PageUp和PageDown分别将图形靠近或者远离我们。</p>
 
      <!-- reward -->
      
      <div id="reward-btn">
        Donate
      </div>
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>Copyright： </strong>
          Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source.
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        Share with
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=https://yaoyl.cn/2017/05/07/OpenGL学习笔记（五）/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/">C++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/OpenGL/">OpenGL</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/nehe/">nehe</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/2017/05/09/OpenGL学习笔记（七）/" class="article-nav-link">
        <strong class="article-nav-caption">last text</strong>
        <div class="article-nav-title">
          
            OpenGL学习笔记（七）
          
        </div>
      </a>
    
    
      <a href="/2017/05/07/OpenGL学习笔记（四）/" class="article-nav-link">
        <strong class="article-nav-caption">next text</strong>
        <div class="article-nav-title">OpenGL学习笔记（四）</div>
      </a>
    
  </nav>

   
<!-- valine评论 -->
<div id="vcomments-box">
  <div id="vcomments"></div>
</div>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js"></script>
<script>
  new Valine({
    el: "#vcomments",
    app_id: "qkDBSm4o58WMY10dnnN3G3DG-gzGzoHsz",
    app_key: "A3yKU51qb7l8hBysTQRJG0Xa",
    path: window.location.pathname,
    avatar: "monsterid",
    placeholder: "给我的文章加点评论吧~",
    recordIP: true,
  });
  const infoEle = document.querySelector("#vcomments .info");
  if (infoEle && infoEle.childNodes && infoEle.childNodes.length > 0) {
    infoEle.childNodes.forEach(function (item) {
      item.parentNode.removeChild(item);
    });
  }
</script>
<style>
  #vcomments-box {
    padding: 5px 30px;
  }

  @media screen and (max-width: 800px) {
    #vcomments-box {
      padding: 5px 0px;
    }
  }

  #vcomments-box #vcomments {
    background-color: #fff;
  }

  .v .vlist .vcard .vh {
    padding-right: 20px;
  }

  .v .vlist .vcard {
    padding-left: 10px;
  }
</style>

 
     
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2017-2020
        <i class="ri-heart-fill heart_icon"></i> Yunyao Long
      </li>
    </ul>
    <ul>
      <li>
        
        
        
        Powered by <a href="https://hexo.io" target="_blank">Hexo</a>
        <span class="division">|</span>
        Theme - <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span></span>
        
      </li>
    </ul>
    <ul>
      
        <li>
          <a href="http://www.beian.miit.gov.cn/" target="_black">粤ICP备-17050867-1号</a>
        </li>
        
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src="https://v1.cnzz.com/z_stat.php?id=1279087554&amp;web_id=1279087554"></script>
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="剑阁"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search" title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <script>
      if (window.matchMedia("(max-width: 768px)").matches) {
        document.querySelector('.content').classList.remove('on');
        document.querySelector('.sidebar').classList.remove('on');
      }
    </script>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechatpay.png">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/lazyload.min.js"></script>
<!-- Tocbot -->

<script src="/js/tocbot.min.js"></script>
<script>
  tocbot.init({
    tocSelector: '.tocbot',
    contentSelector: '.article-entry',
    headingSelector: 'h1, h2, h3, h4, h5, h6',
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: 'main',
    positionFixedSelector: '.tocbot',
    positionFixedClass: 'is-position-fixed',
    fixedSidebarOffset: 'auto'
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>
<script src="/dist/main.js"></script>
<!-- ImageViewer -->

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>

<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->

<script src="/js/busuanzi-2.3.pure.min.js"></script>

<!-- ClickLove -->

<!-- ClickBoom1 -->

<script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script>
<script src="/js/clickBoom1.js"></script>

<!-- ClickBoom2 -->

<!-- CodeCopy -->

<link rel="stylesheet" href="/css/clipboard.css">
<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>


<!-- CanvasBackground -->


    
    <div id="music">
    
    
    
    <iframe frameborder="no" border="1" marginwidth="0" marginheight="0" width="200" height="86" src="//music.163.com/outchain/player?type=2&id=447279413&auto=1&height=66"></iframe>
</div>

<style>
    #music {
        position: fixed;
        right: 15px;
        bottom: 0;
        z-index: 998;
    }
</style>
    
  </div>
</body>

</html>